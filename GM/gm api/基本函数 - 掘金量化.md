---
title: "基本函数 - 掘金量化"
source: "https://www.myquant.cn/docs2/sdk/python/API%E4%BB%8B%E7%BB%8D/%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0.html#init-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%AD%96%E7%95%A5"
author:
published:
created: 2025-09-25
description: "掘金量化支持中心，提供量化学习、答疑、指引等大量文档，包括掘金量化快速入门、操作指引、Python SDK内容、C++ SDK内容、C# SDK内容、Matlab SDK内容、基础数据、行情数据、量化数据、常见问题、量化工具等文档"
published_time:
tags:
  - "#掘金量化 #PythonSDK #量化交易 #策略开发 #API函数"
summary: "掘金量化Python SDK的基本函数介绍，包括策略初始化、定时任务配置、运行停止策略等核心功能。"
---
# 文章总结
掘金量化Python SDK的基本函数介绍，包括策略初始化、定时任务配置、运行停止策略等核心功能。
# 标签
#掘金量化 #PythonSDK #量化交易 #策略开发 #API函数
# 正文内容
## 基本函数

## init - 初始化策略

初始化策略, 策略启动时自动执行。可以在这里初始化策略配置参数。

**函数原型：**

```
init(context)
 
        复制成功
```

**参数：**

| 参数名 | 类型 | 说明 |
| --- | --- | --- |
| context | [context](https://www.myquant.cn/docs2/sdk/python/%E5%8F%98%E9%87%8F%E7%BA%A6%E5%AE%9A.html#context-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AF%B9%E8%B1%A1) | 上下文，全局变量可存储在这里 |

**示例：**

**注意：**

**1.** 回测模式下init函数里不支持交易操作，仿真模式和实盘模式支持。

**2.** init只会在策略启动时运行一次，如果不是每天重启策略，每天需要查询更新数据，可以通过设置定时任务执行。

## schedule - 定时任务配置

在指定时间自动执行策略算法, 通常用于选股类型策略

**函数原型：**

```
schedule(schedule_func, date_rule, time_rule)
 
        复制成功
```

**参数：**

| 参数名 | 类型 | 说明 |
| --- | --- | --- |
| schedule\_func | function | 策略定时执行算法 |
| date\_rule | str | n + 时间单位， 可选'd/w/m' 表示 n 天/n 周/n 月 |
| time\_rule | str | 执行算法的具体时间 (%H:%M:%S 格式) |

**返回值：**

`None`

**示例：**

```python
def init(context):
    #每天的19:06:20执行策略algo_1
    schedule(schedule_func=algo_1, date_rule='1d', time_rule='19:06:20')
    #每月的第一个交易日的09:40:00执行策略algo_2
    schedule(schedule_func=algo_2, date_rule='1m', time_rule='9:40:00')

def algo_1(context):
    print(context.symbols)

def algo_2(context):
    order_volume(symbol='SHSE.600000', volume=200, side=OrderSide_Buy, order_type=OrderType_Market, position_effect=PositionEffect_Open)

 
        复制成功
```

**注意：**

**1.** time\_rule 的时,分,秒均不可以只输入个位数，例:`'9:40:0'` 或 `'14:5:0'`

**2.** 目前暂时支持 `1d` 、 `1w` 、 `1m` ，其中 `1w` 、 `1m` 仅用于回测

## run - 运行策略

**函数原型：**

```python
run(strategy_id='', filename='', mode=MODE_UNKNOWN, token='', backtest_start_time='',
    backtest_end_time='', backtest_initial_cash=1000000,
    backtest_transaction_ratio=1, backtest_commission_ratio=0,
    backtest_slippage_ratio=0, backtest_adjust=ADJUST_NONE, backtest_check_cache=1,
    serv_addr='', backtest_match_mode=0, backtest_intraday=0)
 
        复制成功
```

**参数：**

| 参数名 | 类型 | 说明 |
| --- | --- | --- |
| strategy\_id | str | 策略 id |
| filename | str | 策略文件名称 |
| mode | int | 策略模式 MODE\_LIVE(实时)=1 MODE\_BACKTEST(回测) =2 |
| token | str | 用户标识 |
| backtest\_start\_time | str | 回测开始时间 (%Y-%m-%d %H:%M:%S 格式) |
| backtest\_end\_time | str | 回测结束时间 (%Y-%m-%d %H:%M:%S 格式) |
| backtest\_initial\_cash | double | 回测初始资金, 默认 1000000 |
| backtest\_transaction\_ratio | double | 回测成交比例, 默认 1.0, 即下单 100%成交 |
| backtest\_commission\_ratio | double | 回测佣金比例, 默认 0 |
| backtest\_slippage\_ratio | double | 回测滑点比例, 默认 0 |
| backtest\_adjust | int | 回测复权方式(默认不复权) ADJUST\_NONE(不复权)=0 ADJUST\_PREV(前复权)=1 ADJUST\_POST(后复权)=2 |
| backtest\_check\_cache | int | 回测是否使用缓存：1 - 使用， 0 - 不使用；默认使用 |
| serv\_addr | str | 终端服务地址, 默认本地地址, 可不填，若需指定应输入 ip+端口号，如"127.0.0.1:7001" |
| backtest\_match\_mode | int | 回测市价撮合模式： 1-实时撮合：在当前 bar 的收盘价/当前 tick 的 price 撮合，0-延时撮合：在下个 bar 的开盘价/下个 tick 的 price 撮合，默认是模式 0 |
| backtest\_intraday | int | 回测模式不订阅行情，current 和 current\_price 行情数据查询函数返回的日线价格类型：   1 - 当日收盘价: 回测当前交易日的日线收盘价（T日盘中和盘后均为T日收盘价）;   0 - 历史收盘价：回测当前时刻的历史最新日线收盘价（T日盘中为T-1日收盘价，T日盘后为T日收盘价），默认是0 |

**返回值：**

`None`

**示例：**

```python
run(strategy_id='strategy_1', filename='main.py', mode=MODE_BACKTEST, token='token_id',
    backtest_start_time='2016-06-17 13:00:00', backtest_end_time='2017-08-21 15:00:00')
 
        复制成功
```

**注意：**

**1.** run 函数中， `mode=1` 也可改为 `mode=MODE_LIVE` ，两者等价， `backtest_adjust` 同理

**2.** 在前复权和后复权回测模式下，是不会处理分红、送股、拆分事件的，因为除权除息产生的变动已经通过复权因子调整反映在前复权/后复权股价中，无需重复处理。不复权会自动处理分红送转。

**3.** filename 指运行的 py 文件名字，如该策略文件名为 Strategy.py,则此处应填"Strategy.py"

## stop - 停止策略

停止策略，退出策略进程

**函数原型：**

```python
stop()
 
        复制成功
```

**返回值：**

`None`

**示例：**

```python
#若订阅过的代码集合为空，停止策略
if not context.symbols:
   stop()
 
        复制成功
```

## timer - 设置定时器

设定定时器的间隔秒数，每过设定好的秒数调用一次计时器 timer\_func()，直到 timer\_stop()结束定时器为止。 （仿真、实盘场景适用，回测模式下不生效）

**函数原型：**

```python
timer(timer_func, period, start_delay)
 
        复制成功
```

**参数：**

| 参数名 | 类型 | 说明 |
| --- | --- | --- |
| timer\_func | function | 在 timer 设置的时间到达时触发的事件函数 |
| period | int | 定时事件间隔毫秒数，设定每隔多少毫秒触发一次定时器，范围在 \[1,43200000\] |
| start\_delay | int | 等待秒数(毫秒)，设定多少毫秒后启动定时器，范围在\[0,43200000\] |

**返回值： dict**

| 字段 | 类型 | 说明 |
| --- | --- | --- |
| timer\_status | int | 定时器设置是否成功，成功=0，失败=非 0 错误码（timer\_id 无效）。 |
| timer\_id | int | 设定好的定时器 id |

## timer\_stop - 停止定时器

停止已设置的定时器

**函数原型：**

```python
timer_stop(timer_id)
 
        复制成功
```

**参数：**

| 字段 | 类型 | 说明 |
| --- | --- | --- |
| timer\_id | int | 要停止的定时器 id |

**返回值：**

| 字段 | 类型 | 说明 |
| --- | --- | --- |
| is\_stop | bool | 是否成功停止，True or False |

**示例：**

```python
def init(context):
    # 每隔1分钟执行ontime_1, 即时启动
    context.timerid_1 = timer(timer_func=ontimer_1, period=60000, start_delay=0)
    context.counter_1 = 0

    # 每隔半小时执行ontime_2, 5分钟之后启动
    context.timerid_2 = timer(timer_func=ontimer_2, period=300000, start_delay=0)
    print('启动定时器2：', context.now)
    context.counter_2 = 0

def ontimer_1(context):
    # 定时器执行次数计数
    context.counter_1 += 1
    # 定时器执行逻辑
    print('定时器1：', context.now)

def ontimer_2(context):
    # 定时器执行次数计数
    context.counter_2 += 1
    # 定时器执行逻辑（如查询账户资金）
    cash = context.account().cash

    print('定时器2：', context.now)

    # 按执行次数条件停止定时器
    if context.counter_1 >= 5:
        ret1 = timer_stop(context.timerid_1['timer_id'])
        if ret1:
            print("结束1分钟定时器")

    if context.counter_2 >= 10:
        ret2 = timer_stop(context.timerid_2['timer_id'])
 
        复制成功
```

**注意：**

**1.** 仿真、实盘场景适用，回测模式下不生效

**2.** period 从前一次事件函数开始执行时点起算，若下一次事件函数需要执行时，前一次事件函数没运行完毕，等待上一个事件执行完毕再执行下一个事件。

---